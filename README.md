## Modular Proxy

This repository hosts my take on the EIP-2535 proxy pattern. It works using the same mechanics as EIP-2535, but strips out a lot of the code to simplify the implementation. Contracts are built out using "modules" using namespaced storage rather than the default solidity storage layout. This pattern allows for an effectively unlimited contract size, eliminates the possibility of storage alignment errors in upgrades, and provides unlimited flexibility due to overcoming the limitation in libraries of accessing contract storage. Also, there is no need in this pattern to expose any "init" functions, negating the need for any modifiers like "initialized."

The contract principally works by maintaining a mapping of function selectors to implementation addresses. The proxy forwards calls to implementations based on this mapping, and any accounts that control this mapping essentially control upgradeability. This means that proxy contracts can be delegate calling many different contracts, which sounds very scary. The solution is to use namespaced storage. Using namespaced storage alleviates the principal concern of keeping contract storage in sync between implementations, which applies in the scenarios of upgrading proxies, and in this case, delegate calling multiple different contracts. Goodbye storage gaps.
